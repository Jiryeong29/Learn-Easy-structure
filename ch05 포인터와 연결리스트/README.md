# ch05 포인터와 연결리스트

# ch05 포인터와 연결리스트

```cpp
그동안 코드를 짤 때마다 주소에 접근할 때는 함수에 매개변수로 메모리까지 넘겨줄 때 라서 레퍼런스로 매개변수를 레퍼런스로 받게 하는게 고작이었는데..

포인터 너무 어렵다 ! 여태껏 이해하기를 포기한 쾌락의 대가인걸까 ! 흑흑

포인터맛 맵다 매워 ! 매콤하지 못해 고약하다 !
```

> **학습목표**
1. 포인터의 개념을 이해한다.
2. 포인터 관련 연산자를 이해하고 활용능력을 기른다.
3. 동적 메모리의 할당과 반납의 메커니즘을 이해한다.
4. 2차원 배열의 동적할당과 해제 방법을 이해한다.
5. 연결리스트의 개념을 이해한다.
6. 스택과 큐를 연결리스트로 구현하는 방법을 이해한다.
7. 연결리스트로 자료구조를 구현하는 능력을 기른다.
> 

## 5.1 포인터

컴퓨터의 메모리는 바이트 단위로 구성되어 있으며 각 바이트마다 순차적으로 주소가 매겨져 있습니다.

### 다음 코드의 정확한 의미를 설명해보시오.

```cpp
char ch = 'a';
char* p;
p = &ch;

*****p = 'b';  // ch = 'b'; 와 동일
					 // p가 가리키는 곳의 내용을 'b'로 교체
char** pp; // 이중포인터 변수 pp를 선언
pp = &p;   // p의 주소를 pp에 복사
```

1. char ch = ‘a’; 
char형 ch 변수를 선언하고 초기화합니다. 메모리에서 char형을 저장할 수 있는 크기의 공간을 찾아 ch란 이름을 부여하고 그 공간에 ‘a’를 복사하는 것입니다. 모든 변수(또는 객체)는 반드시 메모리를 차지하며 주소를 갖지만 상수는 공간을 차지하지도 않고 주소도 없습니다. 
2. char* p;
새로운 포인터 변수 p를 선언한 것입니다. 포인터 역시 변수이기 때문에 메모리를 차지하고 주소를 갖습니다. 자료형이 char이므로 p는 char변수가 저장되어있는 공간의 주소를 저장하기 위해 사용될 것입니다. 포인터 변수의 크기는 컴퓨터의 메모리가 4G바이트를 넘어선 64비트 운영체제에서는 포인터 변수의 크기가 8바이트가 됩니다.
3. p = &ch;
ch의 주소를 포인터 변수 p에 저장하는 문장입니다. 변수의 주소는 &연산자를 변수에 적용하여 얻습니다. 즉 &ch 연산의 결과는 주소(변수 ch가 있는 메모리의 주소)이며, 자료형은 ch가 char형이므로 &ch는 char*이 됩니다. 포인터 변수 p에 변수 ch의 주소가 저장되어 있으며 이것을 보통 “p가 변수 ch를 가리킨다”라고 말합니다.
[사진삽입]
4. *p = 'b';
**포인터 변수가 가리키는 메모리의 내용을 추출하거나 변경하려면 *연산자를 사용합니다.**
*p는 p가 가리키는 곳의 객체를 의미하고 변수 ch를 말합니다.결국 *p와 변수 ch는 전적으로 동일하기 때문에 *p의 값을 변경하면 변수 ch의 값도 바뀝니다.
5. char** pp;
이중 포인터 변수 pp를 선언합니다. pp도 변수이므로 메모리 공간을 차지하고 주소를 갖습니다. pp의 크기는 p와 동일하며 모든 포인터 변수의 크기는 동일합니다. 이것은 하나의 컴퓨터에서 주소체계는 동일하며 주소가 몇 번이든지 주소를 저장하는데 필요한 공간은 동일하기 때문입니다.
6. pp= &p;
변수 p의 주소를 이중 포인터 변수 pp에 복사합니다. &p는 변수 p의 주소를 추출합니다. &p의 자료형은 char**이며 p의 자료형이 char*이므로 &p는 char*형 변수가 들어있는 메모리 주소이므로 char**가 됩니다. 결국 &p의 자료형은 pp의 자료형과 일치하며 &p의 연산 결과를 pp에 복사할 수 있습니다. 이문장으로 *pp와 p는 전적으로 동일해졌습니다.
7. [ 사진첨부]

| 표현 | 자료형 | 동일한 표현 |
| --- | --- | --- |
| ‘a‘ | char(상수) |  |
| ch | char | *p, **pp |
| p | char* | *pp, &ch |
| pp | char** | &p |
- 포인터를 선언할 때는 `*` 는 다음과 같이 어느 쪽에 붙어도 상관없습니다.

```cpp
char* p;
char *p;
```

그러나 의미적으로는 첫 번째 방법이 우수하다고합니다. 그 이유는 변수 이름이 p이고 자료형이 char*인 것이 확실히 나타나기 때문입니다.

그러나 다음과 같이 한 문장으로 여러 개의 포인터 변수를 선언하고자 할 때는 두 번째 방법을 사용해야하는 것에 유의해야 합니다.

```cpp
char* p, q, r; // p는 char*변수, q와 r은 char변수
char *p, *q, *r; // p,q,r 은 모두 char*형 변수
```

### 여러가지 자료형의 대상에 대해 선언될 수 있는 포인터

```cpp
void* p;        // 임의 자료형의 주소를 저장하기 위한 포인터
int *pi;        // int변수의 주소를 저장하기 위한 포인터
int** pp;       // 포인터 변수의 주소를 저장하기 위한 포인터
Test* ps;       // Test객체의 주소를 저장하기 위한 포인터
void(*f)(int);  // int 매개변수를 갖고 반환이 없는 함수의 주소를 저장하기 위한 포인터
pi = (*int)p; // p를 정수 포인터로 변경하여 pi로 대입
```

void *p는 아무것도 가리키지 않는 포인터를 의미합니다.  void포인터는 필요할 때마다 다음과 같이 다른 포인터로 바꾸어서 사용합니다.

### 함수와 포인터

포인터는 함수의 매개변수나 반환형으로 사용될 수 있습니다. 특정한 변수를 가리키는 포인터가 함수의 매개변수로 전달되면 그 포인터를 이용하여 호출된 함수에서 원래의 변수를 변경할 수 있습니다. 두 변수의 값을 서로 바꾸는 swap()함수가 대표적인 예입니다. 물론 이 함수는 레퍼런스 형으로 구현할 수 있습니다.

```cpp
#include <cstdio>
#include <cstdlib>

void swap(int* px, int* py) {
	int tmp;
	tmp = *px;
	*px = *py;
	*py = tmp;
}

void main() {
	int a = 1, b = 3;
	printf("swap을 호출하기 전: a = %d, b = %d\n", a, b);
	swap(&a, &b);
	printf("swap을 호출한 다음 : a = %d, b = %d", a, b);
}
```

### 배열과 포인터

함수의 파라미터로 배열이 전달되면 함수 안에서 배열의 내용을 변경할 수 있습니다. 왜냐하면 배열의 이름이 배열의 첫 번째 항목을 가리키는 포인터처럼 사용되기 때문입니다. 실제로 컴파일러는 배열의 이름에 공간을 할당하지 않는 대신에 배열의 이름이 있는 곳을 배열의 첫 번째 요소의 주소로 대치합니다. 따라서 배열의 이름이 배열의 시작 주솟값이기 때문에 함수의 매개변수로 전달하면 함수에서는 배열의 내용을 직접 건드릴 수 있게 됩니다.

### 객체와 포인터

클래스의 객체에 대한 포인터도 다른 자료형과 차이가 없습니다. 객체의 멤버를 접근하기 위한 편리한 표기법이 `->` 이며 `ps→i`라 쓰는 것은 `(*ps).i`와 동일하지만 더 명확하고 편리합니다.

```cpp
#include <cstdio>
#include <cstdlib>

struct MyNewType {
	int i;
	float f;
};

void main() {
	MyNewType s, * ps;
	ps = &s;
	ps->i = 2;     // (*ps).i = 2; 와 동일
	ps->f = 3.14f; // (*ps).f= 3.14f;와 동일

	printf("%d\n", s.i);
	printf("%f\n", s.f);
}
```

클래스의 객체에 대한 포인터는 자주 함수의 파라미터로 사용됩니다. 

```cpp
double pointdistacne1(Point2D a, Point2D b);
double pointdistacne2(Point2D* pa, Point2D* pb);
```

첫 번째 함수를 호출하면 두 개의 Point2D 변수(객체)에 대한 복사가 일어나는데 이때 복사생성자가 호출됩니다(만약 Point2D 클래스에 복사생성자가 정의되어 있다면 이것이 호출되고, 만약 복사생성자가 없다면 컴파일러가 디폴트 복사 생성자를 제공합니다) 만약 Point2D가 많은 데이터 필드를 가지고 있는 커다란 클래스라면 매개변수의 전달을 위해 많은 메모리의 복사가 필요하고 이것은 시스템에 부담이 될 수 있습니다.

함수의 매개변수를 두 번째 함수와 같이 포인터 형으로 바꾸면 이런 문제가 해결됩니다. 이 함수에서는 Point2D 클래스의 크기와는 상관없이 매개변수 전달을 위해 pa와 pb의 주소만을 복사합니다. 주소값의 복사는 객체의 복사에 비해 훨씬 용이합니다. 

```cpp
double pointdistacne3(Point2D& a, Point2D& b);
```

다음과 같이 레퍼런스를 사용하는 것도 좋은 방법입니다. 이것은 복사가 일어나는 값에 의한 호출(call-by-value)이 아니라 인수에 대한 별명을 사용하여 단순히 참조하는 것으로 참조에 의한 호출(call-by-reference)라고 부릅니다. 이 경우에는 매개변수 전달을 위해 어떤 복사도 일어나지 않습니다.

### 자체 참조 클래스

특별한 클래스로서 멤버 변수들 중에서 동일한 클래스의 객체를 가리키는 포인터가 한 개 이상 존재하는 클래스를 말합니다. 미리 일정한 크기를 할당하는 배열과 달리 일반적으로 항목의 개수를 미리 예측할 수 없는 경우에 자체 참조 클래스를 정의하고 동적으로 객체를 생성하여 이들을 포인터로 연결하는 구조에서 흔히 사용됩니다.

```cpp
struct ListNode{
	char data[10];
	ListNode* link;
}
```

이런 자체 참조는 리스트나 트리를 구성할 대 노드 클래스의 구조로 많이 사용되므로 어렵지만 반드시 알고 넘어가야 합니다. 또한 리스트, 트리, 그래프 등에서 광범위하게 사용될 것이므로 꼭 이해해야 합니다.

### 함수 포인터

변수의 주소뿐 아니라 아래 표현을 사용하면 함수의 주소를 담는 포인터 변수를 선언할 수 있습니다.

```cpp
#include <cstdio>
#include <cstdlib>

void foo(int a)
{
	printf("foo : %d\n", a);
}

void main() {
	//f는 함수의 주소를 담는 Pointer type이다.
	void(*f)(int);
	f = foo;
	f(10);		// == foo(10)
	(*f)(10);	// == f(10)
}
```

### 포인터에 대한 연산

포인터에 대한 연산은 보통의 연산과 다른 의미를 지닙니다. 정수 포인터에 값을 더하거나 빼본다고 생각할 때 다음과 같이 정수 포인터를 생성하고 정수 변수를 가리키도록 해봅시다.

```cpp
int A[5],int *pi;
pi = &A[2];
```

pi+1은 A[3[ pi-1은 A[1]을 가리킵니다. 

| p | 포인터 |
| --- | --- |
| *p | 포인터가 가리키는 값 |
| *p++ | 포인터가 가리키는 값을 가져온 다음, 포인터를 한 칸 증가 |
| *p— | 포인터가 가리키는 값을 가져온 다음, 포인터를 한 칸 감소 |
| (*p)++ | 포인터가 가리키는 값을 증가시킨다. |

### 포인터 사용 시 중의점

- 포인터가 어떤 값을 가리키고 있지 않을 때는 NULL로 설정하는 것이 좋습니다.
    - int * pi = NULL;
- 초기화가 안 된 포인터 변수가 가리키는 곳에 자료를 저장하면 절대 안됩니다.
    - 포인터를 초기화시키지 않고 포인터가 가리키는 곳에 값을 대입하고 있는 코드
        
        ```cpp
        void main(){
        	char* pc;
        	*pc = 'E';
        }
        ```
        
- 포인터 타입 간의 변환 시에는 명시적인 형변환을 사용해야 합니다.
    - 코드는 정수 포인터를 실수 포인터로 바꾸는 코드
        
        ```cpp
        int *pi;
        float *pf;
        pf = (float*)pi;
        ```
        

## 5.2 동적메모리할당

## 5.3 연결리스트

## 5.4 연결리스트로 구현한 스택

## 5.5 포인터의 응용 : 연결 리스트로 구현한 큐