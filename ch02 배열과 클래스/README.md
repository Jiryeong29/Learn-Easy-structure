> **학습목표**
> 
> - 배열의 개념을 이해한다.
> - 함수호출에서의 배열의 전달 방법을 이해한다.
> - 클래스 개념을 이해한다.
> - 자주 사용되는 C++의 문법을 이해한다.
> - 배열을 사용한 클래스를 구현하는 능력을 배양한다.

### 문자열

자료형이 `char` 인 `str`라는 배열에 `game \0over`  문자열이 들어가면 `str` 을 출력하였을 때 `game over` 이 출력되는 것이 아니라 `game` 이 출력된다. 이는 문자열 끝을 나타내는 `\0` 이 문자열이 `over` 앞에 들어갔기 때문이다. 따라서 문자열 NULL 문자 이후의 내용은 문자열에 아무런 영향을 미치지 않는다.

> 문자열을 위해서 표준라이브러리에서 여러가지 함수들이 제공된다. 문자열을 비교하는 strcmp()와 문자열 복사를 위한strcpy()정도만 찾아서 공부해보아라.
> 

- 배열이란 무엇인가요?
    
    여러개의 동일한 자료형의 데이터를 연속된 공간에 저장하는 자료구조입니다.
    
- 배열의 특징은 무엇이 있나요
    - <인덱스, 요소> 쌍의 집합으로 구성되어있습니다.
    - 인덱스를 사용하여 **직접 접근**이 가능합니다.(순차접근 :  연결리스트)
    - 배열의 이름은 **포인터 역할**을 합니다. 배열의 이름을 매개변수로 전달하면 배열의 첫 번째 항목의 주소가 전달됩니다.
    - 삽입연산을 많이 수행하는 경우라면, 배열이나 벡터보다는 연결리스트를 사용하는 것이 좋습니다.
- 벡터란 무엇인가요?
    
    벡터는 c++의 표준 템플릿 라이브러리에서 배열에 여러가지 기능을 추가한 자료형입니다. 기존의 배열에서 불편했던 점들을 개선시켜 일반화 시킨것으로 특징은 다음과 같습니다.
    
    - 배열과 마찬가지로 인덱스로 항목을 접근할 수 있으며 인덱스의 범위는 0부터 원소의개수-1까지입니다.
    - 벡터는 일반 배열보다 자신에 관한 정보를 더 많이 가지고 있습니다. 특히 벡터의 크기나 잠정적으로 가질 수 있는 원소의 개수에 관한 정보를 얻을 수 있습니다.
    - 벡터의 크기는 동적으로 변할 수 있으며 새로운 원소를 벡터의 끝이나 중간에 삽입할 수 있습니다. 메모리 관리도 효율적이고 자동적으로 이루어집니다.
    - 그러나 삽입할 때에는 벡터도 배열처럼 효율적이지 않으므로 삽입연산을 많이 수행하는 경우 벡터보다는 연결리스트를 사용하는 것이 좋습니다.
- 벡터 vs 배열 [회고록]
    
    책에서도 벡터가 배열의 상위버전인것처럼 설명하는데 그럼에도 불구하고 배열을 사용하는 이유가 궁금해졌다.
    
    벡터가 무조건 좋으니 벡터만 사용하면 되는게 아닌가? 프로그램을 항상 작성할때 벡터가 좀 더 쉬워서 항상 벡터를 사용해왔었는데 두 가지 차이점을 확실히 구분하고 필요에 맞게 사용하면 좋을거 같다고 생각하였다. 잘 설명되어있는 몇 가지 글을 가져와 보았다.
    
    [](http://www.infopub.co.kr/info/ebook/pdf/8054-531.PDF)
    
    [[C/C++] 배열과 벡터 속도차이 비교 테스트](https://powerofsummary.tistory.com/47)
    
    [vector와 array의 처리 성능 높이는 방법 (실험)](https://remocon33.tistory.com/600)
    
    [Array 와 Vector의 속도차이](https://nicekon.tistory.com/113)
    
- 구조체란?
    
    배열이 같은 자료형 데이터의 모임이라면 구조체는 다양한 자료형을 데이터를 묶어주는 방법입니다.
    
- 클래스란?
    
    객체를 정의하는 특 또는 설계도를 말하며 멤버변수와 멤버함수로 구성되어있습니다.
    
- 멤버지정접근자란?
    - public 이란?
        
        어떤 클래스나 함수에서도 이 멤버에 접근할 수 있습니다.
        
    - private란?
        
        현재클래스의 멤버함수에만 접근이 가능합니다.
        
    - protected란?
        
        현재클래스와 이 클래스의 자식 클래스의 멤버함수에만 접근이 가능합니다.
        
- 생성된 객체의 멤버에 접근하는 방법은 무엇인가요?
    
    객체명 바로 뒤에 항목연산자 `.` 를 첨가하고 멤버이름을 적습니다.
    
- 생성자란?
    
    객체가 생성될 때 멤버변수에게 초깃값을 제공하고 필요한 초기화 절차를 실행하기 위한 특별한 멤버함수입니다.
    
- 소멸자란?
    
    객체가 파괴 될 때 뒷마무리를 담당하는 함수입니다.
    
- 멤버포기화 리스트란?
    
    데이터멤버를 초기화하는 방법으로 일반함수와 같이 생성자 함수 몸체에서 초기화를 하는 방법과 구분됩니다.
    
    - ex) 예시코드
        
        ```cpp
        car(int s, int g)
        	: speed(s), gear(g){
        
        }
        ```
        
    
- 함수의 오버로딩이란?
    
    함수 이름의 중복을 허용하는 것입니다. 클래스 , 멤버함수, 일반함수에서 모두 사용가능하고 매개변수가 다른 여러개의 함수를 동일한 이름으로 만들 수 있습니다.
    
- 디폴트 매개변수란?
    
    함수의 매개변수에 디폴트 값을 부여하는 것으로 이 함수를 호출하였을 때 인수를 넣으면 그 값이 매개변수로 복사되고 인수가 없으면 디폴트 값이 그 매개변수에 복사됩니다.
    
    - 예시 코드
        
        ```cpp
        void changeCar(int g =4);
        
        myCar.changeCar(2); // g에 2가 복사됨
        myCar.changeCar();  // g에 디폴트값인 4가 복사됨
        ```
        

> cin이나 cout을 사용하려는 이유는 입출력을 할 자료형을 신경 쓰지 않아 편리하다는 점이 있다. 그러나 프로그래밍에서 가장 중요한 것이 자료형이며 항상 자신이 처리하는 데이터의 자료형을 명확히 생각해야 한다. 따라서 printf()나 scanf()를 사용하여 익숙해지는 연습을 먼저 하는 것을 추천한다. 이 두 함수만 잘 활용하면 입출력외에도 파일입출력 fprintf(), fscanf()나 문자열 입출력 sprintf(), sscanf()등을 같은 방식으로 매우 편리하게 할 수 있다. 입출력객체를 잘 이해하고 c++프로그래밍에 익숙하다면 자신에게 편리한 방법을 사용하면 된다.
> 
- this 포인터란
    
    클래스 멤버함수에서 객체 자신의 주소가 필요한 경우 this를 사용합니다. this는 현재 객체의 메모리상의 주소를 반환합니다.
    
- 클래스 상속이란?
    
    기존 클래스의 필드와 메소드를 재사용하도록 부모클래스를 상속하여 자식 클래스를 만드는것
    
- 클래스를 상속하는 이유는 무엇인가요?
    1. 이미 검증된 소프트웨어를 재사용할 수 있으므로 신뢰성이 확보됩니다.
    2. 코드의 중복을 줄여주어 유지보수를 쉽게합니다.
- 오버라이딩이란?
    
    자식클래스에서 부모클래스의 멤버함수를 다시 재정의하는 것을 말합니다.
    
- 클래스의 객체를 배열로 생성할 수 있습니까?
    
    네, 생성할 수 있습니다.
    
- 레퍼런스란 무엇입니까?
    
    메모리 공간에 별명을 붙이는 것으로 대부분 함수의 매개변수에서 레퍼런스 형을 주로 사용합니다.

### 배열과 클래스의 응용 : 다항식 프로그램구현 해보기

데이터 : 음이 아닌 정수 차수와 실수인 계수의 순서쌍 <i, ai>의 집합으로 표현된 다항식

```cpp
ADT of Polynomial
Data
// 음이 아닌 정수 차수와 실수인 계수의 순서쌍 <i, ai>의 집합으로 표현된 다항식
- degree : int// 다항식의 최고 차수
- coef : float[]// 각 항에 대한 계수

Operation
+void read();	// 다항식을 입력받는다.
+void display(const char *str);	// 다항식을 화면에 출력한다.
+bool isZero(); // 최고 차수가 0인지를 검사하여 0이면true를 반환
+void negate(); // 모든 계수의 부호를 바꾼다.
+void add(Polynomial p1, Polynomial p2);  // 다항식 p1과 p2를 더한다
+void mult(Polynomial p1, Polynomial p2); // 다항식 p1과 p2를 곱한다.
```